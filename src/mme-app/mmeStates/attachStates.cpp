

/*
 * Copyright 2021-present Infosys Limited
 *
 * SPDX-License-Identifier: Apache-2.0
 */
 
/**************************************
 * attachStates.cpp
 * This is an auto generated file.
 * Please do not edit this file.
 * All edits to be made through template source file
 * <TOP-DIR/scripts/SMCodeGen/templates/stateMachineTmpls/state.cpp.tt>
 **************************************/


#include "actionTable.h"
#include "actionHandlers/actionHandlers.h"
#include <mmeSmDefs.h>
#include <utils/mmeStatesUtils.h>
#include <utils/mmeTimerTypes.h>

#include "mmeStates/attachStates.h"

using namespace mme;
using namespace SM;


/******************************************************************************
* Constructor
******************************************************************************/
AttachState::AttachState():State()
{
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachState::~AttachState()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachState* AttachState::Instance()
{
        static AttachState state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachState::initialize()
{
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_s1_rel_req_during_attach);
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[S1_REL_REQ_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_nas_pdu_parse_failure);
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[NAS_PDU_PARSE_FAILURE] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachState::getStateId()const
{
	return attach_state;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachState::getStateName()const
{
	return "attach_state";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachStart::AttachStart(): AttachState()
{
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachStart::~AttachStart()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachStart* AttachStart::Instance()
{
        static AttachStart state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachStart::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::validate_imsi_in_ue_context);
                actionTable.setNextState(AttachWfImsiValidateAction::Instance());
                eventToActionsMap[VALIDATE_IMSI] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachStart::getStateId()const
{
	return attach_start;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachStart::getStateName()const
{
	return "attach_start";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfImsiValidateAction::AttachWfImsiValidateAction(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfImsiValidateAction::~AttachWfImsiValidateAction()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfImsiValidateAction* AttachWfImsiValidateAction::Instance()
{
        static AttachWfImsiValidateAction state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfImsiValidateAction::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_air_to_hss);
                actionTable.setNextState(AttachWfAia::Instance());
                eventToActionsMap[IMSI_VALIDATION_SUCCESS] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_identity_request_to_ue);
                actionTable.setNextState(AttachWfIdentityResponse::Instance());
                eventToActionsMap[IMSI_VALIDATION_FAILURE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfImsiValidateAction::getStateId()const
{
	return attach_wf_imsi_validate_action;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfImsiValidateAction::getStateName()const
{
	return "attach_wf_imsi_validate_action";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfAia::AttachWfAia(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfAia::~AttachWfAia()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfAia* AttachWfAia::Instance()
{
        static AttachWfAia state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfAia::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_aia);
                actionTable.addAction(&ActionHandlers::auth_req_to_ue);
                actionTable.setNextState(AttachWfAuthResp::Instance());
                eventToActionsMap[AIA_FROM_HSS] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfAia::getStateId()const
{
	return attach_wf_aia;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfAia::getStateName()const
{
	return "attach_wf_aia";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfIdentityResponse::AttachWfIdentityResponse(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfIdentityResponse::~AttachWfIdentityResponse()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfIdentityResponse* AttachWfIdentityResponse::Instance()
{
        static AttachWfIdentityResponse state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfIdentityResponse::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_identity_response);
                actionTable.addAction(&ActionHandlers::send_air_to_hss);
                actionTable.setNextState(AttachWfAia::Instance());
                eventToActionsMap[IDENTITY_RESPONSE_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfIdentityResponse::getStateId()const
{
	return attach_wf_identity_response;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfIdentityResponse::getStateName()const
{
	return "attach_wf_identity_response";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfAuthResp::AttachWfAuthResp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfAuthResp::~AttachWfAuthResp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfAuthResp* AttachWfAuthResp::Instance()
{
        static AttachWfAuthResp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfAuthResp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::auth_response_validate);
                actionTable.setNextState(AttachWfAuthRespValidate::Instance());
                eventToActionsMap[AUTH_RESP_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfAuthResp::getStateId()const
{
	return attach_wf_auth_resp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfAuthResp::getStateName()const
{
	return "attach_wf_auth_resp";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfAuthRespValidate::AttachWfAuthRespValidate(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfAuthRespValidate::~AttachWfAuthRespValidate()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfAuthRespValidate* AttachWfAuthRespValidate::Instance()
{
        static AttachWfAuthRespValidate state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfAuthRespValidate::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::sec_mode_cmd_to_ue);
                actionTable.setNextState(AttachWfSecCmp::Instance());
                eventToActionsMap[AUTH_RESP_SUCCESS] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_air_to_hss);
                actionTable.setNextState(AttachWfAia::Instance());
                eventToActionsMap[AUTH_RESP_SYNC_FAILURE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_auth_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[AUTH_RESP_FAILURE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfAuthRespValidate::getStateId()const
{
	return attach_wf_auth_resp_validate;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfAuthRespValidate::getStateName()const
{
	return "attach_wf_auth_resp_validate";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfSecCmp::AttachWfSecCmp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfSecCmp::~AttachWfSecCmp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfSecCmp* AttachWfSecCmp::Instance()
{
        static AttachWfSecCmp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfSecCmp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_sec_mode_resp);
                actionTable.addAction(&ActionHandlers::check_esm_info_req_required);
                actionTable.setNextState(AttachWfEsmInfoCheck::Instance());
                eventToActionsMap[SEC_MODE_RESP_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfSecCmp::getStateId()const
{
	return attach_wf_sec_cmp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfSecCmp::getStateName()const
{
	return "attach_wf_sec_cmp";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfEsmInfoCheck::AttachWfEsmInfoCheck(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfEsmInfoCheck::~AttachWfEsmInfoCheck()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfEsmInfoCheck* AttachWfEsmInfoCheck::Instance()
{
        static AttachWfEsmInfoCheck state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfEsmInfoCheck::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_esm_info_req_to_ue);
                actionTable.setNextState(AttachWfEsmInfoResp::Instance());
                eventToActionsMap[ESM_INFO_REQUIRED] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_ulr_to_hss);
                actionTable.setNextState(AttachWfUla::Instance());
                eventToActionsMap[ESM_INFO_NOT_REQUIRED] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfEsmInfoCheck::getStateId()const
{
	return attach_wf_esm_info_check;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfEsmInfoCheck::getStateName()const
{
	return "attach_wf_esm_info_check";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfEsmInfoResp::AttachWfEsmInfoResp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfEsmInfoResp::~AttachWfEsmInfoResp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfEsmInfoResp* AttachWfEsmInfoResp::Instance()
{
        static AttachWfEsmInfoResp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfEsmInfoResp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_esm_info_resp);
                actionTable.addAction(&ActionHandlers::send_ulr_to_hss);
                actionTable.setNextState(AttachWfUla::Instance());
                eventToActionsMap[ESM_INFO_RESP_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfEsmInfoResp::getStateId()const
{
	return attach_wf_esm_info_resp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfEsmInfoResp::getStateName()const
{
	return "attach_wf_esm_info_resp";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfUla::AttachWfUla(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfUla::~AttachWfUla()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfUla* AttachWfUla::Instance()
{
        static AttachWfUla state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfUla::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_ula);
                actionTable.addAction(&ActionHandlers::cs_req_to_sgw);
                actionTable.setNextState(AttachWfCsResp::Instance());
                eventToActionsMap[ULA_FROM_HSS] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfUla::getStateId()const
{
	return attach_wf_ula;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfUla::getStateName()const
{
	return "attach_wf_ula";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfCsResp::AttachWfCsResp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfCsResp::~AttachWfCsResp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfCsResp* AttachWfCsResp::Instance()
{
        static AttachWfCsResp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfCsResp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_cs_resp);
                actionTable.addAction(&ActionHandlers::send_init_ctxt_req_to_ue);
                actionTable.setNextState(AttachWfInitCtxtRespAttCmp::Instance());
                eventToActionsMap[CS_RESP_FROM_SGW] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts_for_csreq_ind);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfCsResp::getStateId()const
{
	return attach_wf_cs_resp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfCsResp::getStateName()const
{
	return "attach_wf_cs_resp";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfInitCtxtRespAttCmp::AttachWfInitCtxtRespAttCmp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfInitCtxtRespAttCmp::~AttachWfInitCtxtRespAttCmp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfInitCtxtRespAttCmp* AttachWfInitCtxtRespAttCmp::Instance()
{
        static AttachWfInitCtxtRespAttCmp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfInitCtxtRespAttCmp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_init_ctxt_resp);
                actionTable.setNextState(AttachWfAttCmp::Instance());
                eventToActionsMap[INIT_CTXT_RESP_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_attach_cmp_from_ue);
                actionTable.setNextState(AttachWfInitCtxtResp::Instance());
                eventToActionsMap[ATT_CMP_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_s1_rel_req_during_attach);
                actionTable.addAction(&ActionHandlers::abort_attach);
                actionTable.addAction(&ActionHandlers::default_s1_release_req_handler);
                eventToActionsMap[S1_REL_REQ_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::del_session_req);
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfInitCtxtRespAttCmp::getStateId()const
{
	return attach_wf_init_ctxt_resp_att_cmp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfInitCtxtRespAttCmp::getStateName()const
{
	return "attach_wf_init_ctxt_resp_att_cmp";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfInitCtxtResp::AttachWfInitCtxtResp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfInitCtxtResp::~AttachWfInitCtxtResp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfInitCtxtResp* AttachWfInitCtxtResp::Instance()
{
        static AttachWfInitCtxtResp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfInitCtxtResp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_init_ctxt_resp);
                actionTable.addAction(&ActionHandlers::send_mb_req_to_sgw);
                actionTable.setNextState(AttachWfMbResp::Instance());
                eventToActionsMap[INIT_CTXT_RESP_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_s1_rel_req_during_attach);
                actionTable.addAction(&ActionHandlers::abort_attach);
                actionTable.addAction(&ActionHandlers::default_s1_release_req_handler);
                eventToActionsMap[S1_REL_REQ_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::del_session_req);
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfInitCtxtResp::getStateId()const
{
	return attach_wf_init_ctxt_resp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfInitCtxtResp::getStateName()const
{
	return "attach_wf_init_ctxt_resp";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfAttCmp::AttachWfAttCmp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfAttCmp::~AttachWfAttCmp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfAttCmp* AttachWfAttCmp::Instance()
{
        static AttachWfAttCmp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfAttCmp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_attach_cmp_from_ue);
                actionTable.addAction(&ActionHandlers::send_mb_req_to_sgw);
                actionTable.setNextState(AttachWfMbResp::Instance());
                eventToActionsMap[ATT_CMP_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_s1_rel_req_during_attach);
                actionTable.addAction(&ActionHandlers::abort_attach);
                actionTable.addAction(&ActionHandlers::default_s1_release_req_handler);
                eventToActionsMap[S1_REL_REQ_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::del_session_req);
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfAttCmp::getStateId()const
{
	return attach_wf_att_cmp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfAttCmp::getStateName()const
{
	return "attach_wf_att_cmp";
}

/******************************************************************************
* Constructor
******************************************************************************/
AttachWfMbResp::AttachWfMbResp(): AttachState()
{
        stateGuardTimeoutDuration_m = defaultStateGuardTimerDuration_c;
        stateEntryAction = &MmeStatesUtils::on_state_entry;
        stateExitAction = &MmeStatesUtils::on_state_exit;
        eventValidator = &MmeStatesUtils::validate_event;
		
}

/******************************************************************************
* Destructor
******************************************************************************/
AttachWfMbResp::~AttachWfMbResp()
{
}

/******************************************************************************
* creates and returns static instance
******************************************************************************/
AttachWfMbResp* AttachWfMbResp::Instance()
{
        static AttachWfMbResp state;
        return &state;
}

/******************************************************************************
* initializes eventToActionsMap
******************************************************************************/
void AttachWfMbResp::initialize()
{
        AttachState::initialize();
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::process_mb_resp);
                actionTable.addAction(&ActionHandlers::check_and_send_emm_info);
                actionTable.addAction(&ActionHandlers::attach_done);
                eventToActionsMap[MB_RESP_FROM_SGW] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_attach_request);
                actionTable.addAction(&ActionHandlers::del_session_req);
                actionTable.addAction(&ActionHandlers::abort_attach);
                actionTable.addAction(&ActionHandlers::default_attach_req_handler);
                eventToActionsMap[ATTACH_REQ_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_s1_rel_req_during_attach);
                actionTable.addAction(&ActionHandlers::abort_attach);
                actionTable.addAction(&ActionHandlers::default_s1_release_req_handler);
                eventToActionsMap[S1_REL_REQ_FROM_UE] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::handle_state_guard_timeouts);
                eventToActionsMap[STATE_GUARD_TIMEOUT] = actionTable;
        }
        {
                ActionTable actionTable;
                actionTable.addAction(&ActionHandlers::del_session_req);
                actionTable.addAction(&ActionHandlers::send_attach_reject);
                actionTable.addAction(&ActionHandlers::send_s1_rel_cmd_to_ue);
                actionTable.addAction(&ActionHandlers::abort_attach);
                eventToActionsMap[ABORT_EVENT] = actionTable;
        }
}

/******************************************************************************
* returns stateId
******************************************************************************/
uint16_t AttachWfMbResp::getStateId()const
{
	return attach_wf_mb_resp;
}

/******************************************************************************
* returns stateName
******************************************************************************/
const char* AttachWfMbResp::getStateName()const
{
	return "attach_wf_mb_resp";
}
