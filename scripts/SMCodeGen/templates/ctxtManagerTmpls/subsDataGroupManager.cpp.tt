[%- DataGroup = TemplateInputVar %]
[%- USE String %]
[%- PROCESS templates/ctxtManagerTmpls/commonMacro.tt -%]
/*
 * Copyright 2019-present Infosys Limited
 *
 * SPDX-License-Identifier: Apache-2.0
 */
 
/**************************************
 *
 * This is an auto generated file.
 * Please do not edit this file.
 * All edits to be made through template source file
 * <TOP-DIR/scripts/SMCodeGen/templates/ctxtManagerTmpls/subsDataGroupManager.cpp.tt>
 ***************************************/
[%- IF DataGroup.DgName == 'Subs' %]
#include "contextManager/[%  FILENAME(DataGroup.DgName, "") %]DataGroupManager.h"
[%- ELSE %]
#include "[% FILENAME(DataGroup.DgName, "") %]ContextManager/[%  FILENAME(DataGroup.DgName, "") %]DataGroupManager.h"
[%- END %]

namespace mme
{
	/******************************************************************************
	* Constructor
	******************************************************************************/
	[% DataGroup.DgName %]DataGroupManager::[% DataGroup.DgName %]DataGroupManager()
	{
		[%- FOREACH DataBlock = DataGroup.DataBlocks %]
			[% CLASSNAME(DataBlock.BlockName, "Manager") %]m_p = NULL;
		[%- END %]

			initialize();
	}
	
	/******************************************************************************
	* Destructor
	******************************************************************************/
	[% DataGroup.DgName %]DataGroupManager::~[% DataGroup.DgName %]DataGroupManager()
	{
		[%- FOREACH DataBlock = DataGroup.DataBlocks %]
			delete [% CLASSNAME(DataBlock.BlockName, "Manager") %]m_p;
		[%- END %]
	}
	
	/******************************************
	*  Initializes control block and pool managers
	******************************************/
	void [% DataGroup.DgName %]DataGroupManager::initialize()
	{
		initializeCBStore([% DataGroup.PoolSize %]);

		[%- FOREACH DataBlock = DataGroup.DataBlocks %]
		[% CLASSNAME(DataBlock.BlockName, "Manager") %]m_p = new [% CLASSNAME(DataBlock.BlockName, "Manager") %]([% DataBlock.PoolSize %]);
		[%- END %]
	}
	
	/******************************************************************************
	* creates and returns static instance
	******************************************************************************/
	[% DataGroup.DgName %]DataGroupManager* [% DataGroup.DgName %]DataGroupManager::Instance()
	{
	        [%- instanceName_1 = String.new(DataGroup.DgName.substr(0,1)).lower.append(DataGroup.DgName.substr(1)) %]
			static [% DataGroup.DgName %]DataGroupManager [% instanceName_1 %]DataGroupMgr;
			return &[% instanceName_1 %]DataGroupMgr;
	}

	[%- FOREACH DataBlock = DataGroup.DataBlocks %]
	[% DataBlock.BlockName %]* [% DataGroup.DgName %]DataGroupManager::get[% DataBlock.BlockName %]()
	{
		return [% CLASSNAME(DataBlock.BlockName, "Manager") %]m_p->allocate[% DataBlock.BlockName %]();
	}

	void [% DataGroup.DgName %]DataGroupManager::delete[% DataBlock.BlockName %]([% DataBlock.BlockName %]* [% DataBlock.BlockName %]p )
	{
		[% CLASSNAME(DataBlock.BlockName, "Manager") %]m_p->deallocate[% DataBlock.BlockName %]( [% DataBlock.BlockName %]p );
	}
	[%- END %]
	
	[%- FOREACH DataBlock = DataGroup.DataBlocks %]
		[%- FOREACH Data = DataBlock.Data %]
			[%- IF Data.Key == 'Yes' %]
	/******************************************
	* Add a [% Data.Name %] as key and cb index as value to [% Data.Name %]_cb_id_map
	******************************************/
	int [% DataGroup.DgName %]DataGroupManager::add[% Data.Name %]key( [% Data.Type %] key, int cb_index )
	{
		std::lock_guard<std::mutex> lock([% Data.Name %]_cb_id_map_mutex);

		int rc = 1;

		auto itr = [% Data.Name %]_cb_id_map.insert(std::pair<[% Data.Type %], int>( key, cb_index ));
		if (itr.second == false)
		{
			rc = -1;
		}
		return rc;
	}
	
	/******************************************
	* Delete a [% Data.Name %] key from [% Data.Name %]_cb_id_map
	******************************************/
	int [% DataGroup.DgName %]DataGroupManager::delete[% Data.Name %]key( [% Data.Type %] key )
	{
		std::lock_guard<std::mutex> lock([% Data.Name %]_cb_id_map_mutex);
 
		return [% Data.Name %]_cb_id_map.erase( key );
	}
	
	/******************************************
	* Find cb with given [% Data.Name %] from [% Data.Name %]_cb_id_map
	* returns -1 if not found, else cb index
	******************************************/ 
	int [% DataGroup.DgName %]DataGroupManager::findCBWith[% Data.Name %]( [% Data.Type %] key )
	{
		std::lock_guard<std::mutex> lock([% Data.Name %]_cb_id_map_mutex);
        
		auto itr = [% Data.Name %]_cb_id_map.find( key );
		if( itr != [% Data.Name %]_cb_id_map.end())
		{
			return itr->second;
		}
		return -1;
	}
		     [%- END %]
	    [%- END %]
[%- END %]
}